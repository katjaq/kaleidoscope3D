<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<style>
			body {
				background-color: #ffffff;
				margin: 0;
				overflow: hidden;
			}
		</style>
	</head>
	<body>

		<div style="position:absolute;background-color:#fff">
		<input type="text" value="2" id="iterations" onchange="handleTransformChange()"/>Iterations<br />
		<input type="text" value="1" id="scale" onchange="handleTransformChange()"/>Scale<br />
		<input type="range" min="0" max="360" id="rotx" onmousemove="handleTransformChange()"/>Rotation X<br />
		<input type="range" min="0" max="360" id="roty" onmousemove="handleTransformChange()"/>Rotation Y<br />
		<input type="range" min="0" max="360" id="rotz" onmousemove="handleTransformChange()"/>Rotation Z<br />
		<a id="saveSTL" href=#>Save STL</a>
		</div>

		<script src="jquery-1.11.0.min.js"></script>
		<script src="three.min.js"></script>
		<script src="PLYLoader.js"></script>
		<script src="TrackballControls.js"></script>
		<script src="CSG.js"></script>
		<script>

			var camera, scene, renderer;
			var geometry, mesh=undefined;
			var	points,faces;	// points and faces of the original object
			var	tb;
			var	D=50;	// kaleidoscope triangle: 1/3 of the height

			var init = function () {
				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				document.body.appendChild( renderer.domElement );
				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 500;
				tb = new THREE.TrackballControls(camera,renderer.domElement);
				scene = new THREE.Scene();
				
				$("#saveSTL").click(function(){
					var stl = getSTL();
		
					var name = prompt("Object name","Untitled");
					if(name==undefined)
						return;

					var stlData = 'data:application/csv;charset=utf-8,' + encodeURIComponent( stl );
					this.href = stlData;
					this.target = '_blank';
					this.download = name+'.stl';
				});
				
				// load test object
				//var path="rings.ply";
				//var path="sphere+cyl.ply";
				var path="mesh.ply";
				var oReq = new XMLHttpRequest();
				oReq.open("GET", path, true);
				oReq.responseType="text";
				oReq.onload = function(oEvent)
				{
					var tmp=this.response;
					var ge=new THREE.PLYLoader().parse(tmp);
					points=ge.vertices;
					faces=ge.faces;
					center(points);
					scale(points,100,100,100);
					
					kaleidoscope({ scale:{x:1,y:1,z:1},
								   translate:{x:0,y:0,z:0},
								   rotate:{x:0,y:0,z:0}},
								 points,faces);
				};
				oReq.send();
			}

			var animate = function () {

				requestAnimationFrame( animate );

				if(mesh==undefined)
					return;
				
				//mesh.rotation.x = Date.now() * 0.0002;
				//mesh.rotation.y = Date.now() * 0.0001;

				renderer.render( scene, camera );
				tb.update();

			}
			function cross3D(a, b) {
				return {x:a.y*b.z-a.z*b.y,y:a.z*b.x-a.x*b.z,z:a.x*b.y-a.y*b.x};
			}
			function sub3D(a,b) {
				return {x:(a.x-b.x),y:(a.y-b.y),z:(a.z-b.z)};
			}
			function sca3D(a,t) {
				return {x:a.x*t,y:a.y*t,z:a.z*t};
			}
			function norm3D(a) {
				return Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z);
			}
			function normal3D(pa,pb,pc) {

				var n=cross3D(sub3D(pb,pa),sub3D(pc,pa));
				return sca3D(n,1/norm3D(n));
			}

			function getSTL() {
			    var i,stl=[],t,pa,pb,pc;
			    
			    stl.push("solid myKaleidoscope3D");

				for(i=0;i<geometry.faces.length;i++)
				{
					
					t=geometry.faces[i];
					pa=geometry.vertices[t.a];
					pb=geometry.vertices[t.b];
					pc=geometry.vertices[t.c];
					n=normal3D(pa,pb,pc);
					stl.push("facet normal "+n.x+" "+n.y+" "+n.z);
					stl.push("outer loop");
					stl.push("vertex "+pa.x+" "+pa.y+" "+pa.z);
					stl.push("vertex "+pb.x+" "+pb.y+" "+pb.z);
					stl.push("vertex "+pc.x+" "+pc.y+" "+pc.z);
					stl.push("endLoop");
					stl.push("endFacet");
				}
				stl.push("endSolid mySolid");
				stl=stl.join("\n");
				
				return stl;
			}
			function handleTransformChange(e)
			{
				var it=parseFloat(document.getElementById('iterations').value);
				var s=parseFloat(document.getElementById('scale').value);
				var rx=parseFloat(document.getElementById('rotx').value)*Math.PI/180;
				var ry=parseFloat(document.getElementById('roty').value)*Math.PI/180;
				var rz=parseFloat(document.getElementById('rotz').value)*Math.PI/180;
				var param={ scale:{x:s,y:s,z:s},
							translate:{x:0,y:0,z:0},
							rotate:{x:rx,y:ry,z:rz}};

				kaleidoscope(param,points,faces);
				for(i=1;i<it;i++)
					kaleidoscope(param,geometry.vertices,geometry.faces);
			}
			function kaleidoscope(param,p0,f0) {
				var i,j;
				var	cp0=clonePoints(p0);	// points to crop
				var cf0=cloneFaces(f0);		// faces to crop
				var p1,f1;					// points and faces to transform
				var	off;
				
				scale(cp0,param.scale.x,param.scale.y,param.scale.z);
				rotate(cp0,param.rotate.x,param.rotate.y,param.rotate.z);
				translate(cp0,param.translate.x,param.translate.y,param.translate.z);
				crop(cp0,cf0);
				
				p1=[];
				f1=[];
				var d=0;
				for(i=0;i<6;i++) {
					var ptmp=clonePoints(cp0);
					var ftmp=cloneFaces(cf0);
					flip(ptmp,ftmp,1-2*(i%2),1,1);
					rotate(ptmp,0,0,Math.PI/3*(i+2));
					translate(ptmp,2*(D+d)*Math.cos(Math.PI/3*(i+0.5)),2*(D+d)*Math.sin(Math.PI/3*(i+0.5)),0);
					append(p1,f1,ptmp,ftmp);
				}

				geometry=new THREE.Geometry();
				geometry.vertices=p1;
				geometry.faces=f1;
				geometry.computeFaceNormals();
				geometry.computeVertexNormals();
				if(mesh)
					scene.remove(mesh);
				mesh = new THREE.Mesh(geometry,new THREE.MeshNormalMaterial());
				scene.add( mesh );
				
				console.log(p1.length);
			}

			
			// intersect3D_SegmentPlane(): find the 3D intersection of a segment and a plane
			//    Input:  S = a segment, and Pn = a plane = {Point V0;  Vector n;}
			//    Output: *I0 = the intersect point (when it exists)
			//    Return: 0 = disjoint (no intersection)
			//            1 =  intersection in the unique point *I0
			//            2 = the  segment lies in the plane
			//			  3 = segment is too short to cut the plane
			function intersectSegmentPlane(p0,p1, v0,n)
			{
				var u = {x:p1.x-p0.x,y:p1.y-p0.y,z:p1.z-p0.z};
				var w = {x:p0.x-v0.x,y:p0.y-v0.y,z:p0.z-v0.z};
				var SMALL_NUM=0.000001;
				var	inter;

				var     D = n.x*u.x+n.y*u.y+n.z*u.z; //dot(Pn.n, u)
				var     N = -(n.x*w.x+n.y*w.y+n.z*w.z); //-dot(Pn.n, w)

				if (Math.abs(D) < SMALL_NUM) {                   // segment is parallel to plane
					if (N == 0)                                  // segment lies in plane
						return {f:2,s:0,i:0};
					else
						return {f:0,s:0,i:0};                    // no intersection
				}
				// they are not parallel
				// compute intersect param
				var sI = N / D;
				if (sI < 0 || sI > 1)
					return {f:3,s:sI,i:0};                       // no intersection

				inter = new THREE.Vector3(p0.x+sI*u.x,p0.y+sI*u.y,p0.z+sI*u.z); // compute segment intersect point
				return {f:1,s:sI,i:inter};
			}
			function sign(p,p0,n0)
			{
				return (p.x-p0.x)*n0.x+(p.y-p0.y)*n0.y+(p.z-p0.z)*n0.z;
			}

			function crop(p,f)
			{
				var i,j,k,o;
				var flag,inter;
				var	v0=[];	// 2 plane points
				var	n0=[];	// 2 plane normals
				var	a,b,r;
				var pa,pb,pc;
				var	sa,sb,sc;
				
				// configure cropping planes in V
				for(i=0;i<2;i++)
				{
					a=(30+120*i)*Math.PI/180;
					b=(-150+120*i)*Math.PI/180;
					v0[i]={x:D*Math.cos(a),y:D*Math.sin(a),z:0};	// point
					n0[i]={x:Math.cos(b),y:Math.sin(b),z:0};		// normal
				}
				
				// crop
				o=0;
				for(k=0;k<2;k++)
				{
					var pp=[],ff=[];
					for(i=0;i<f.length;i++)
					{
						var newp=[];
					
						pa=p[f[i].a];
						pb=p[f[i].b];
						pc=p[f[i].c];
					
						sa=sign(pa,v0[k],n0[k]);
						sb=sign(pb,v0[k],n0[k]);
						sc=sign(pc,v0[k],n0[k]);
					
						if(sa>=0) newp.push(pa);
						if(sa*sb<0)
						{
							r=intersectSegmentPlane(pa,pb,v0[k],n0[k]);
							if(r.f==1)
								newp.push(r.i);
						}
						if(sb>=0) newp.push(pb);
						if(sb*sc<0)
						{
							r=intersectSegmentPlane(pb,pc,v0[k],n0[k]);
							if(r.f==1)
								newp.push(r.i);
						}
						if(sc>=0) newp.push(pc);
						if(sc*sa<0)
						{
							r=intersectSegmentPlane(pc,pa,v0[k],n0[k]);
							if(r.f==1)
								newp.push(r.i);
						}
					
						o=pp.length;
						for(j=0;j<newp.length;j++)
							pp.push(new THREE.Vector3(newp[j].x,newp[j].y,newp[j].z));
						for(j=0;j<newp.length-2;j++)
							ff.push(new THREE.Face3(o,o+j+1,o+j+2));
					}
					p.length=0;
					f.length=0;
					for(j=0;j<pp.length;j++) p.push(pp[j]);
					for(j=0;j<ff.length;j++) f.push(ff[j]);
				}				
			}
			function center(p)
			{
				var i,el,o=[0,0,0];
				for(i=0;i<p.length;i++) {
					el=p[i];
					o[0]+=el.x;
					o[1]+=el.y;
					o[2]+=el.z;
				}
				o[0]/=p.length;
				o[1]/=p.length;
				o[2]/=p.length;
				for(i=0;i<p.length;i++) {
					el=p[i];
					el.x-=o[0];
					el.y-=o[1];
					el.z-=o[2];
				}
			}
			function scale(p,sx,sy,sz)
			{
				var i;
				for(i=0;i<p.length;i++) {
					p[i].x*=sx;
					p[i].y*=sy;
					p[i].z*=sz;
				}
			}
			function translate(p,sx,sy,sz)
			{
				var i;
				for(i=0;i<p.length;i++) {
					p[i].x+=sx;
					p[i].y+=sy;
					p[i].z+=sz;
				}
			}
			function rotate(p,alpha,beta,gamma)
			{
				var m = new THREE.Matrix4();
				var m1 = new THREE.Matrix4();
				var m2 = new THREE.Matrix4();
				var m3 = new THREE.Matrix4();
				
				m1.makeRotationX( alpha );
				m2.makeRotationY( beta );
				m3.makeRotationZ( gamma );
				
				m.multiplyMatrices( m1, m2 );
				m.multiply( m3 );
				
				var i;
				for(i=0;i<p.length;i++)
					p[i].applyMatrix4(m);
			}
			function clonePoints(p)
			{
				var j,p0=[];
				for(j=0;j<p.length;j++)
					p0[j]=new THREE.Vector3(p[j].x,p[j].y,p[j].z);
				return p0;
			}
			function cloneFaces(f)
			{
				var j,f0=[];
				for(j=0;j<f.length;j++)
					f0[j]=new THREE.Face3(f[j].a,f[j].b,f[j].c);
				return f0;
			}
			function append(p0,f0,p,f)
			{
				var	i,o=p0.length;
				for(i=0;i<p.length;i++)
					p0.push(new THREE.Vector3(p[i].x,p[i].y,p[i].z));
				for(i=0;i<f.length;i++)
					f0.push(new THREE.Face3(f[i].a+o,f[i].b+o,f[i].c+o));
			}
			function flip(p,f,flipx,flipy,flipz)
			{
				var i,a,b,c;
				for(i=0;i<p.length;i++) {
					p[i].x*=flipx;
					p[i].y*=flipy;
					p[i].z*=flipz;
				}
				if(flipx*flipy*flipz<0)
				{
					for(i=0;i<f.length;i++)
					{
						b=f[i].b;
						f[i].b=f[i].c;
						f[i].c=b;
					}
				}
			}

			init();
			animate();

				/*
				points=[new THREE.Vector3(0,0,0),new THREE.Vector3(1,0,0),new THREE.Vector3(1,1,0),new THREE.Vector3(0,1,0),
						new THREE.Vector3(0,0,1),new THREE.Vector3(1,0,1),new THREE.Vector3(1,1,1),new THREE.Vector3(0,1,1)];
				faces=[new THREE.Face3(0,2,1),new THREE.Face3(0,3,2),new THREE.Face3(1,6,5),new THREE.Face3(1,2,6),
						new THREE.Face3(2,7,6),new THREE.Face3(2,3,7),new THREE.Face3(3,4,7),new THREE.Face3(3,0,4),
						new THREE.Face3(0,5,4),new THREE.Face3(0,1,5),new THREE.Face3(5,7,4),new THREE.Face3(5,6,7)];

				// center and scale the test object
				center(points);
				scale(points,100,100,100);
				//append(geometry,points,faces);

				crop(points,faces);
				//translate(points,150,0,0);
				//append(geometry,points,faces);
				
				var i;
				for(i=0;i<6;i++)
				{
					p0=clonePoints(points);
					f0=cloneFaces(faces);
					flip(p0,f0,1-2*(i%2),1,1);
					rotate(p0,0,0,Math.PI/3*(i+2));
					translate(p0,100*Math.cos(Math.PI/3*(i+0.5)),100*Math.sin(Math.PI/3*(i+0.5)),0);
					append(geometry,p0,f0);
				}

				geometry.computeFaceNormals();
				geometry.computeVertexNormals(); 

				material = new THREE.MeshNormalMaterial({ overdraw: 0.5,wireframe: true});
				//material = new THREE.MeshBasicMaterial( {color:'red',wireframe: false, wireframeLinewidth: 2 } );
				mesh = new THREE.Mesh( geometry, material );
				scene.add( mesh );
				*/
			
		</script>
	</body>
</html>
